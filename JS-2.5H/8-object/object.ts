// @ts-nocheck
// ==============================================KONU-ANLATIMI=================================================//

// ========== TEMEL OBJE OLU≈ûTURMA ==========
// Literal syntax ile obje olu≈üturma
const product: any = {
    id: 1,
    name: 'Bilgisayar',
    price: 15000,
    stock: 10,

    // Metod tanƒ±mlama
    discount(percent) {
        this.price *= (1 - percent / 100);
        return `%${percent} indirim uygulandƒ±. Yeni fiyat: ${this.price}‚Ç∫`;
    }
};

// CRUD Operasyonlarƒ±
// Create - Yeni √∂zellik ekleme
product.category = 'Elektronik';

// Read - Deƒüer okuma
console.log(product.name); // 'Bilgisayar'

// Update - Deƒüer g√ºncelleme
product.price = 16750;

// Delete - √ñzellik silme
delete product.stock;

// ========== SPREAD & REST OPERAT√ñRLERƒ∞ ==========

// Objeleri birle≈ütirme (spread)
const updatedProduct = {
    ...product,               // Spread operat√∂r√º ile 'product' objesinin t√ºm √∂zelliklerini 'updatedProduct' objesine alƒ±yoruz
    warranty: '2 Yƒ±l',        // Yeni bir √∂zellik ekliyoruz: warranty
    price: 15549,             // 'price' √∂zelliƒüini g√ºncelliyoruz (mevcut √∂zellik override ediliyor)
};

// Rest operat√∂r√º ile kalan √∂zellikleri alma
const {id, ...productInfo} = updatedProduct;  // 'id' √∂zelliƒüini alƒ±yoruz, geri kalanlarƒ± 'productInfo' objesinde topluyoruz
console.log(productInfo);  // 'productInfo' objesini yazdƒ±rƒ±yoruz: {name: 'Bilgisayar', price: 15500, warranty: '2 Yƒ±l'}


// ========== DESTRUCTURING ==========
// Objeden deƒüer √ßƒ±karma
const {name: productName, price} = product;
console.log(productName, price); // 'Bilgisayar' 15500

// Nested objelerde destructuring:
// Destructuring, bir array ya da object i√ßindeki verileri tek satƒ±rda deƒüi≈ükenlere ayƒ±rmanƒ± saƒülar.
const company = {
    name: 'Tech Corp',
    address: {
        city: 'ƒ∞stanbul',
        district: 'Kadƒ±k√∂y'
    }
};
const {address: {city, district}} = company;
console.log(city); // 'ƒ∞stanbul'

// ========== OBJE METOTLARI ==========
// Object.keys() - Nesnenin anahtarlarƒ±nƒ± dizi olarak verir.
const product = { id: 1, name: "Bilgisayar", price: 15000 };
console.log(Object.keys(product)); // ["id", "name", "price"]

// Object.values() - Nesnenin deƒüerlerini dizi olarak d√∂nd√ºr√ºr.
console.log(Object.values(product)); // [1, "Bilgisayar", 15000]

// Object.entries() - Anahtar-deƒüer √ßiftlerini dizi i√ßinde dizi olarak verir.
console.log(Object.entries(product)); // [["id", 1], ["name", "Bilgisayar"], ["price", 15000]]

// Object.assign() - Nesneleri hedefe kopyalar, hedefi d√∂nd√ºr√ºr.
const target = { a: 1 };
const source = { b: 2, c: 3 };
Object.assign(target, source);
console.log(target); // { a: 1, b: 2, c: 3 }
// target: kopyalanacak nesne, source: kopyalanan nesne. Aynƒ± anahtar varsa son deƒüer ge√ßerli.

// Object.fromEntries() - Dizi i√ßindeki anahtar-deƒüer √ßiftlerinden nesne olu≈üturur.
const entries = [["a", 1], ["b", 2]];
console.log(Object.fromEntries(entries)); // { a: 1, b: 2 }

// Object.create() - Prototip ile nesne olu≈üturur.
const proto = { greet: () => "Merhaba" };
const obj = Object.create(proto);
console.log(obj.greet()); // "Merhaba"

// Object.defineProperty() - √ñzellik tanƒ±mlar ve kontrol eder.
const newObj = {};
Object.defineProperty(newObj, "key", {
    value: 42,
    writable: false // Deƒüi≈ütirilemez
});
newObj.key = 100; // √áalƒ±≈ümaz
console.log(newObj.key); // 42

// Object.hasOwnProperty() - √ñzelliƒüin nesneye ait olup olmadƒ±ƒüƒ±nƒ± kontrol eder.
const checkObj = { a: 1 };
console.log(checkObj.hasOwnProperty("a")); // true
console.log(checkObj.hasOwnProperty("toString")); // false (prototipte)

// Object.is() - ƒ∞ki deƒüerin tam e≈üitliƒüini kontrol eder.
console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(0, -0)); // false

// Object.preventExtensions() - Yeni √∂zellik eklenmesini engeller.
const lockedObj = { a: 1 };
Object.preventExtensions(lockedObj);
lockedObj.b = 2; // Eklenmez
lockedObj.a = 3; // Deƒüi≈üir
console.log(lockedObj); // { a: 3 }

// Object.getPrototypeOf() - Nesnenin prototipini d√∂nd√ºr√ºr.
const protoCheck = {};
console.log(Object.getPrototypeOf(protoCheck) === Object.prototype); // true

// ========== NESNE Kƒ∞Lƒ∞TLEME METOTLARI ==========
const config = {apiUrl: 'https://api.example.com'};

// Object.seal() - Yeni √∂zellik eklenemez, mevcutlar deƒüi≈ütirilebilir
// üåê Frontend'de global config ayarlarƒ±
const appConfig = {
    theme: "dark",
    language: "en"
};
Object.seal(appConfig);

// Mevcut olanƒ± deƒüi≈ütirmek m√ºmk√ºn:
appConfig.theme = "light"; // ‚úîÔ∏è

// Yeni √∂zellik eklemek yasak:
appConfig.layout = "grid"; // ‚ùå YOK SAYILIR (strict moddaysan hata verir)

// √ñzellik silmek de yasak:
delete appConfig.language; // ‚ùå √áalƒ±≈ümaz

// Object.freeze() - Tamamen dondurma
// Bir butonun sabit stilleri
const buttonStyles = Object.freeze({
    color: "#fff",
    background: "#007bff",
    borderRadius: "5px"
});

// Deƒüi≈ütirmeye √ßalƒ±≈üalƒ±m
//buttonStyles.color = "#000";       // ‚ùå Deƒüi≈ümez
buttonStyles.shadow = "2px";       // ‚ùå Eklenmez
//delete buttonStyles.borderRadius;  // ‚ùå Silinmez

// ========== Dƒ∞NAMƒ∞K √ñZELLƒ∞KLER ==========
// Computed property names
const dynamicKey = 'status_' + Date.now();
const order = {
    id: 5,
    [dynamicKey]: 'processing'
};
console.log(order); // {id:5, status_1623...: 'processing'}

// Dinamik √∂zellik ekleme/silme
const propName = 'totalAmount';
order[propName] = 2500;
console.log(order.totalAmount); // 2500

// ========== DERƒ∞N NESNE MANƒ∞P√úLASYONU ==========
// Nested object update with spread
const user = {
    name: 'Ali',
    preferences: {
        theme: 'dark',
        notifications: true
    }
};

// Deep update
const updatedUser = {
    ...user,
    preferences: {
        ...user.preferences,
        theme: 'light'
    }
};

// ========== JSON ƒ∞≈ûLEMLERƒ∞ ==========

// JavaScript objesini JSON string'ine √ßevirir
const productJSON = JSON.stringify(product);
console.log('JSON:', productJSON);
// √áƒ±ktƒ± √∂rneƒüi: '{"name":"Kalem","price":10}'
// JSON.stringify() metodu, objenin metodlarƒ±nƒ± (fonksiyonlarƒ±nƒ±) dahil etmez.

// JSON string'ini tekrar bir JavaScript objesine √ßevirir
const parsedProduct = JSON.parse(productJSON);
console.log('Parsed:', parsedProduct);
// √áƒ±ktƒ± √∂rneƒüi: { name: "Kalem", price: 10 }
// JSON.parse() metodu, string halindeki veriyi bir obje haline getirir.


// ==============================================√ñRNEKLER=================================================//

// ========== √ñrnek 1: PROTOKOL ve CLASS YAPISI ==========
class Product {
    constructor(name, price) {
        this.name = name;
        this.price = price;
    }

    applyDiscount(percent) {
        this.price *= (1 - percent / 100);
    }
}
const laptop = new Product('Diz√ºst√º Bilgisayar', 20000);
laptop.applyDiscount(10);
console.log(laptop.price); // 18000



// ========== √ñrnek2: GER√áEK D√úNYA √ñRNEƒûƒ∞: SEPET Y√ñNETƒ∞Mƒ∞ ==========
const cartSystem = {
    cart: [],
    products: {
        'P1': {name: 'Mouse', price: 250},
        'P2': {name: 'Klavye', price: 500}
    },

    addToCart(productId, quantity = 1) {
        if (!this.products[productId]) return '√úr√ºn bulunamadƒ±';

        const item = {
            ...this.products[productId],
            quantity,
            total: this.products[productId].price * quantity
        };

        this.cart.push(item);
        return `Sepete eklendi: ${quantity}x ${item.name}`;
    },

    removeFromCart(productId) {
        this.cart = this.cart.filter(item => item.id !== productId);
    },

    calculateTotal() {
        return this.cart.reduce((sum, item) => sum + item.total, 0);
    }
};

// Kullanƒ±m
cartSystem.addToCart('P1', 2);
cartSystem.addToCart('P2');
console.log('Toplam:', cartSystem.calculateTotal());
console.log('Sepet:', cartSystem.cart);





//√ñrnek3: Object ve Sipari≈ü Sistemi
// 1Ô∏è‚É£ Men√º Olu≈üturma (CREATE)
const cafeMenu = {
    kahve: 20,
    cay: 10,
    kek: 15,
    sandvic: 25
};
console.log("Men√º:", cafeMenu);

// 2Ô∏è‚É£ Object Metodlarƒ± (READ)
console.log("√úr√ºnler:", Object.keys(cafeMenu));
console.log("Fiyatlar:", Object.values(cafeMenu));
console.log("√áiftler:", Object.entries(cafeMenu));

// 3Ô∏è‚É£ Spread & Rest Kullanƒ±mƒ±
const {kek, cay, ...kalanlar} = cafeMenu;
console.log("Se√ßilen:", {kek, cay});
console.log("Kalanlar:", kalanlar);

// 4Ô∏è‚É£ Men√º Kopyalama & G√ºncelleme (UPDATE)
const newMenu = {...cafeMenu, su: 5, kahve: 22};
console.log("G√ºncel Men√º:", newMenu);

// 5Ô∏è‚É£ √úr√ºn Silme (DELETE)
const silinmisMenu = {...cafeMenu};
delete silinmisMenu.sandvic;
console.log("Sandvi√ßsiz Men√º:", silinmisMenu);

// 6Ô∏è‚É£ JSON.stringify / parse
const str = JSON.stringify(cafeMenu);
const backToObj = JSON.parse(str);
console.log("JSON string:", str);
console.log("Geri obje:", backToObj);

// 7Ô∏è‚É£ Deep Copy
const nestedMenu = {icecekler: {kahve: 20}, yiyecekler: {kek: 15}};
const deepCopy = JSON.parse(JSON.stringify(nestedMenu));
deepCopy.icecekler.kahve = 30;
console.log("Orijinal:", nestedMenu);
console.log("Deep Copy:", deepCopy);

// 8Ô∏è‚É£ ƒ∞ndirimli Men√º
const discountedMenu = Object.fromEntries(
    Object.entries(cafeMenu).map(([k, v]) => [k, v * 0.9])
);
console.log("ƒ∞ndirimli Men√º:", discountedMenu);

// 9Ô∏è‚É£ Sipari≈ü Sistemi
const cafeOrders = {
    musteri1: {items: {kahve: 2, kek: 1}, time: "10:00"},
    musteri2: {items: {cay: 3}, time: "10:05"}
};

// Sipari≈üi formatla + fiyat hesapla
const formatOrder = (items) =>
    Object.entries(items).map(([k, v]) => `${k}: ${v} adet`).join(", ");
const calculateTotal = (items, menu) =>
    Object.entries(items).reduce((t, [k, v]) => t + (menu[k] || 0) * v, 0);

console.log("M√º≈üteri 1 sipari≈üi:", formatOrder(cafeOrders.musteri1.items));
console.log("M√º≈üteri 1 toplam:", calculateTotal(cafeOrders.musteri1.items, cafeMenu));

// Yeni sipari≈ü + t√ºm toplam
const allOrders = {
    ...cafeOrders,
    musteri3: {items: {sandvic: 1}, time: "10:10"}
};
const totalAll = Object.values(allOrders).reduce(
    (acc, o) => acc + calculateTotal(o.items, cafeMenu),
    0
);
console.log("T√ºm Sipari≈üler Toplamƒ±:", totalAll);

// üîü Kitap√ßƒ± Sistemi (Kƒ±sa Versiyon)
const bookCatalog = {
    kitap1: {title: "JS", price: 50, category: "Programlama", stock: 10},
    kitap2: {title: "Python", price: 40, category: "Programlama", stock: 5},
    kitap3: {title: "Tarih", price: 30, category: "Tarih", stock: 0},
    kitap4: {title: "Roman", price: 25, category: "Edebiyat", stock: 8}
};
const orders = {
    user1: {items: {kitap1: 2, kitap4: 1}},
    user2: {items: {kitap2: 1, kitap3: 1}}
};
const calculateBookTotal = (items, catalog) =>
    Object.entries(items).reduce((t, [id, qty]) => t + (catalog[id]?.price || 0) * qty, 0);
console.log("User1 toplam:", calculateBookTotal(orders.user1.items, bookCatalog));

// ƒ∞ndirim + kategori ayƒ±rma
const discountedCatalog = Object.fromEntries(
    Object.entries(bookCatalog).map(([id, b]) => [id, {...b, price: b.price * 0.8}])
);
const {kitap1, kitap2, ...digerdir} = discountedCatalog;
console.log("Programlama dƒ±≈üƒ± kitap sayƒ±sƒ±:", Object.keys(digerdir).length);
//digerdir ‚Üí kitap1 ve kitap2 dƒ±≈üƒ±ndaki kitaplar demek.
// Yani aslƒ±nda: programlama dƒ±≈üƒ± kitaplar.



